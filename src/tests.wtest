import snake.*
import wollok.game.*
import food.*

describe "Directions" {

	const unaPosicion = game.at(2, 2)

	test "toUp.next devuelve una posicion arriba" {
		assert.equals(game.at(2, 3), toUp.next(unaPosicion))
	}

	test "toDown.next devuelve una posicion abajo" {
		assert.equals(game.at(2, 1), toDown.next(unaPosicion))
	}

	test "toRight.next devuelve una posicion a la derecha" {
		assert.equals(game.at(3, 2), toRight.next(unaPosicion))
	}

	test "toLeft.next devuelve una posicion a la izquierda" {
		assert.equals(game.at(1, 2), toLeft.next(unaPosicion))
	}

	test "toUp.previous devuelve una posicion abajo" {
		assert.equals(game.at(2, 1), toUp.previous(unaPosicion))
	}

	test "toDown.previous devuelve una posicion arriba" {
		assert.equals(game.at(2, 3), toDown.previous(unaPosicion))
	}

	test "toRight.previous devuelve una posicion a la izquierda" {
		assert.equals(game.at(1, 2), toRight.previous(unaPosicion))
	}

	test "toLeft.previous devuelve una posicion a la derecha" {
		assert.equals(game.at(3, 2), toLeft.previous(unaPosicion))
	}

}

describe "Food" {

	method isInsideBoard(pos) {
		const tooHight = pos.y() >= game.height()
		const tooLow = pos.y() < 0
		const tooRight = pos.x() >= game.width()
		const tooLeft = pos.x() < 0
		return not tooHight && not tooLow && not tooRight && not tooLeft
	}

	test "randomPos devuelve una posicion dentro de los limites" {
		game.height(10)
		game.width(10)
		assert.that(self.isInsideBoard(apple.randomPos()))
	}

	test "collideWithSnake aumenta timesCollided y cambia la posicion de apple" {
		const posInicial = apple.position()
		// Agrego el evento onTick para que no falle el metodo collideWithSnakeHead
		game.onTick(snakeHead.speed(0), "MOVE SNAKE", { snakeHead.changePosition()})
		apple.collideWithSnakeHead(snakeHead)
		assert.notEquals(posInicial, apple.position())
		assert.equals(1, apple.timesCollided())
	}

}

describe "snakeHead y SnakeBody" {

	test "addBodyPart genera un nuevo SnakeBody donde 'next' es nulo" {
		assert.equals(null, snakeHead.next())
		snakeHead.addBodyPart()
		const body1 = snakeHead.next()
		assert.notEquals(null, body1)
		assert.equals(null, body1.next())
		snakeHead.addBodyPart()
		assert.notEquals(null, body1.next())
		assert.equals(null, body1.next().next())
	}

	test "addBodyPart agrega los SnakeBody como visuales al objeto game" {
		snakeHead.addBodyPart()
		assert.that(game.hasVisual(snakeHead.next()))
	}

	test "changeDirection cambia la direccion de todos los SnakeBody" {
		snakeHead.addBodyPart()
		// Guardo la direccion actual
		const currentDir = snakeHead.direction()
		// Cambio la direccion de la cabeza
		snakeHead.changeDirection(toRight)
		assert.equals(toRight, snakeHead.direction())
		assert.equals(currentDir, snakeHead.next().direction())
	}

	test "changePosition cambia la posicion de todos los SnakeBody" {
		snakeHead.addBodyPart()
		// Guardo la direccion actual
		const currentPos = snakeHead.position()
		// Cambio la direccion de la cabeza
		snakeHead.changePosition()
		assert.equals(snakeHead.direction().next(currentPos), snakeHead.position())
		assert.equals(currentPos, snakeHead.next().position())
	}

	test "Si se sale del board, se remueve el evento 'MOVE SNAKE'" {
		game.addVisual(snakeHead)
		game.onTick(snakeHead.speed(0), "MOVE SNAKE", { snakeHead.changePosition()})
		4.times{ i => snakeHead.changePosition()}
		assert.that(snakeHead.outOfBoundaries())
		assert.throwsException({game.removeTickEvent("MOVE SNAKE") })
	}
	
	test "Al llamar removeLast tira error y finaliza el juego si no hay SnakeBody's" {
		assert.throwsException({snakeHead.removeLast()})
	}
	
	test "Al llamar removeLast se elimina solo el ultimo SnakeBody" {
		snakeHead.addBodyPart()
		const last = snakeHead.next()
		snakeHead.removeLast()
		assert.equals(null, snakeHead.next())
		assert.equals(null, last.prev())
	}

}

